#!/usr/bin/env python2.7.6
---------------------------------------------------------------------------

import platform
import os
import shutil
import traceback
import glob
import time
import logging
import re
import subprocess

def getCurTimeStr():
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    return time.strftime('%Y-%m-%d %X',time.localtime(time.time()))

def is_win32():
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    sys_name = platform.system()
    return True if sys_name in ("Windows", "Microsoft") else False

def is_linux():
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    sys_name = platform.system()
    return True if sys_name == "Linux" else False

def is_ea80():
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    ret, txt = getstatusoutput("emake -v")
    if ret != 0:
        return False
    if txt.startswith("Electric Make version 8.0"):
        return True
    return False

def is_gbts(ins_name):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    for insname in ins_name:
        return True if (insname.find("rosarb_gbts")!=-1) or (insname =="gbts") else False

def is_gsm_lib(ins_name):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    for insname in getlist(ins_name):
        return True if (insname.find("rosarb_gsm")!=-1) or (insname =="hert_gsm") or (insname =="gbts_ine" and is_win32()) else False

def getstatusoutput(cmd):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    cmd_process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    cmd_echo = cmd_process.stdout.read()
    cmd_process.stdout.close()
    sts = cmd_process.wait()
    try:
        cmd_echo = cmd_echo.decode('UTF-8')
    except UnicodeDecodeError:
        cmd_echo = cmd_echo.decode('gbk', errors='ignore')
    if int(platform.python_version().split('.')[0]) < 3:
        if platform.system() == 'Windows':
            cmd_echo = cmd_echo.encode('gbk', errors='ignore')
        else:
            cmd_echo = cmd_echo.encode('UTF-8', errors='ignore')
    if cmd_echo[-1:] == '\n': cmd_echo = cmd_echo[:-1]
    return sts, cmd_echo

def glob_r(root_path, file_list):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    for path in glob.glob(os.path.join(root_path, "*")):
        if path == root_path:
            continue
        if os.path.isfile(path):
            file_list.append(path)
        else:
            glob_r(path, file_list)

def mkdir_r(path):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    if os.path.exists(path):
        return
    mkdir_r(os.path.dirname(path))
    os.mkdir(path)

def rmdir_r(path, filter = ""):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    for it in os.listdir(path):
        it_path = os.path.join(path, it)
        if filter != "" and True == filter(it_path):
            continue
        if os.path.isfile(it_path):
            os.remove(it_path)
        elif os.path.isdir(it_path):
            rmdir_r(it_path)
    if len(os.listdir(path)) == 0:
        os.rmdir(path)

def proc_var_path(path, sep = os.sep):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    infos = path.split(sep)
    path_list = []
    for info in infos:
        info = info.strip()
        begin_idx = 0
        tmp_chr = ""
        while 1:
            begin = info.find("$(", begin_idx)
            end = info.find(")", begin_idx)
            if begin >= end or begin == -1:
                break
            pre = "" if begin_idx == begin else info[begin_idx:begin]
            var = info[begin + len("$("):end]
            var = os.environ[var]
            tmp_chr = tmp_chr + pre + var
            begin_idx = end + len(")")
        tmp_chr = tmp_chr if begin_idx == len(info) else tmp_chr + info[begin_idx:]
        path_list.append(tmp_chr)
    return os.sep.join(path_list)

def replace_env(in_str):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    env_list = re.findall(".*?\\$\\((.*?)\\).*?", in_str)
    for env in env_list:
        if env in os.environ.keys():
            in_str = in_str.replace("$(%s)" % env, os.environ[env])
    return in_str

def get_init_py(path):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    file_list = []
    tmp_path = os.path.abspath(path)
    while 1:
        folder = os.path.dirname(tmp_path)
        if folder == tmp_path:
            break
        tmp_path = folder
        init_file = os.path.join(folder, "__init__.py")
        if not os.path.exists(init_file):
            break
        file_list.append(init_file)
    return file_list

def getlist(obj):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    return obj if isinstance(obj, list) else [obj]

def split_list(list_obj, piece_num):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    return [list_obj[i:i + piece_num] for i in range(0, len(list_obj), piece_num)]

def myRmdir(_dir):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    sysType = platform.system()
    if "Windows" == sysType or "Microsoft" == sysType:
        cmd = "rmdir /s /q \"%s\"" % _dir
    elif "Linux" == sysType:
        cmd = "rm -f -r \"%s\"" % _dir
    else:
        cmd = ""
    logging.info(cmd)
    subprocess.call(cmd, shell=True)

def myDelDirAllFile(_dir):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    for fileName in os.listdir(_dir):
        if fileName == ".svn":continue
        _file = os.path.join(_dir, fileName)
        if os.path.isfile(_file):
            os.remove(_file)
        if os.path.isdir(_file):
            myRmdir(_file)

def myDel(_file, isRecursion = True):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    sysType = platform.system()
    if "Windows" == sysType:
        if isRecursion:
            cmd = "del /s /q \"%s\"" % _file
        else:
            cmd = "del /q \"%s\"" % _file
    elif "Linux" == sysType:
        if isRecursion:
            cmd = "rm -f -r %s" % _file
        else:
            cmd = "rm -f %s" % _file
    else:
        cmd = ""
    logging.info(cmd)
    subprocess.call(cmd, shell=True)

def mysyscall(cmd):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    logging.info(cmd)
    sts, text = getstatusoutput(cmd)
    logging.info(text)
    if sts != 0:
        return False
    return True

def mkDir(fileName):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    fileName = os.path.abspath(fileName)
    dirList = fileName.split(os.sep)

    dirName = dirList[0]
    # 如果是远程，跳过前2个
    if dirName == "":
        beginIdx = 3  # \\\\10.166.159.22\public\agc
    else:
        beginIdx = 1
    for i in range(1, len(dirList)):
        dirName = dirName + os.sep + dirList[i]
        if i <= beginIdx: continue  # 考虑到远程的情况
        if not os.path.isdir(dirName):
            os.mkdir(dirName)

def isFileNameFilter(filename, filter, excludelist):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    if filename in excludelist: return True
    if filter == "*": return False
    if filter == "*.*": return False

    tmp = filter.split(".")
    if len(tmp) < 2:
        filter1 = tmp[0]
        filter2 = "*"
    else:
        filter1 = tmp[0]
        filter2 = tmp[1]

    tmp = filename.split(".")
    if len(tmp) < 2:
        filename1 = tmp[0]
        filename2 = "*"
    else:
        filename1 = tmp[0]
        filename2 = tmp[1]
    if filter1 != "*" and filter1.lower() == filename1.lower(): return True
    if filter2 != "*" and filter2.lower() == filename2.lower(): return True

    return False
			
def isMatchFileNameFilter(filename, filter, excludelist):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    if filename in excludelist: return False
    if filter == "*": return True
    if filter == "*.*": return True

    tmp = filter.split(".")
    if len(tmp) < 2:
        filter1 = tmp[0]
        filter2 = "*"
    else:
        filter1 = tmp[0]
        filter2 = tmp[1]

    tmp = filename.split(".")
    if len(tmp) < 2:
        filename1 = tmp[0]
        filename2 = "*"
    else:
        filename1 = tmp[0]
        filename2 = tmp[1]

    if filter1 != "*" and filter1.lower() != filename1.lower(): return False
    if filter2 != "*" and filter2.lower() != filename2.lower(): return False

    return True

def myXcopy_(src, des, filter, isRecursion = True, isCopy2 = False, excludelist = [], isFilter = False):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    filelist = os.listdir(src)
    for filename in filelist:
        fullPathsrc = os.path.join(src, filename)
        fullPathdes = os.path.join(des, filename)
        if os.path.isdir(fullPathsrc):
            if filename == ".svn": continue
            if isRecursion: myXcopy_(fullPathsrc, fullPathdes, filter, isRecursion, isCopy2, excludelist, isFilter)
        if os.path.isfile(fullPathsrc):
            if False == isFilter:
                if False == isMatchFileNameFilter(filename, filter, excludelist): continue
            else:
                flag = False
                filterlist=filter.split(",")
                for filter_tmp in filterlist:
                    if True == isFileNameFilter(filename, filter_tmp, excludelist): 
                        flag = True
                if True == flag: continue
            logging.info("copy to: %s -> %s" % (src, fullPathdes))
            if False == os.path.isdir(des):
                logging.info("mkdir: %s" % des)
                mkDir(des)
            if False == isCopy2:
                shutil.copyfile(fullPathsrc, fullPathdes)
            else:
                shutil.copy2(fullPathsrc, fullPathdes)

def myXcopy(src, des, filter = "*", isRecursion = True, isCopy2 = False, excludelist = [], isFilter = False):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    if False == os.path.isdir(src):
        return 1
    myXcopy_(src, des, filter, isRecursion, isCopy2, excludelist, isFilter)

	
	
	
def CopyFile(src, des):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    if not os.path.isfile(src):
        logging.info("warning: can't find %s" % src)
        return
    if is_win32():
        path = des.replace("/", "\\").split("\\")[:-1]
        path = "\\".join(path)
        src = src.replace("/", "\\")
        des = des.replace("/", "\\")
    else:
        path = des.replace("\\", "/").split("/")[:-1]
        src = src.replace("\\", "/")
        des = des.replace("\\", "/")
        path = "/".join(path)
    if not os.path.isdir(path):
        mkDir(path)
    shutil.copyfile(src, des)

def killPid(pid):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    subprocess.call("taskkill /PID %d /T /F" % pid, shell=True)

def lst_del_repeat(lst):
    """
    Purpose:
    Globals:
    Arguments:
    Returns:
    """
    ret_lst = []
    [ret_lst.append(i) for i in lst if not i in ret_lst]
    return ret_lst
