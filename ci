# -*- coding: gb2312 -*-

import os, sys
import glob
import shutil
import thread
import threading
import time
# from sms import *

curfile = os.path.realpath(__file__)
curpath = os.path.dirname(curfile)
os.environ["WORK_SCRIPT_PATH"] = curpath
os.environ["SUCC_ROOT_PATH"] = os.path.join(os.environ["WORK_SCRIPT_PATH"], "succFiles")

#SRC_PKG_DIR=r"\\10.184.237.220\HERT510C00_pkg_backup"
SRC_PKG_DIR=r"\\9.120.20.1\HERT510C00_pkg_backup"
SRC_PKG_DIR_TRIGGER=r"\\10.156.17.188\ctu_ci_nas\HERT_BBU\510C00_Software_Package_01"
DST_PKG_DIR=r"\\10.184.124.102\hertbbu\HERT510C00_Daily_Soft"
 # 调试路径，调试完请注释掉
# DST_PKG_DIR_LIST=[r"D:\temp\fangzheng"] 
PREFIX = '510C00_TRUNK_'
env_info = {
            "MBTS" : {"pkg_prefix": r"MBTS",
                      "pkg_pstfix": r"",
                      "smokeLst": ['umpt', 'umptb', 'umpte','wmpt','gtmuc','lmpt']
                     },
            #"UMTS" : {"pkg_prefix": r"MBTS\Nodeb",
            #          "pkg_pstfix": r"Nodeb",
            #          "smokeLst": ['wmpt']
            #         },
            #"UMDU" : {"pkg_prefix": r"MBTS",
            #          "pkg_pstfix": r"",
            #          "smokeLst": ['umdu']
            #         },
            "USU"  : {"pkg_prefix": r"USU",
                      "pkg_pstfix": r"",
                      "smokeLst": ['usu']
                     },
            "USU3910" : {"pkg_prefix": r"USU3910",
                      "pkg_pstfix": r"",
                      "smokeLst": ['usu3910']
                     },
            # "USE"  : {"pkg_prefix": r"USE",
                       # "pkg_pstfix": r"",
                       # "smokeLst": [r"umptb_use", "umpte_use"]
                     # },
            "GBTS"  : {"pkg_prefix": r"gbts",
                      "pkg_pstfix": r"",
                      "smokeLst": ['gbts']
                     },
        }

threadExitNum = 0
returnValuelst = []
mutex = threading.Lock()

'''
1、按时间给符合条件的目录排序（需过滤）
2、按模块依次找到冒烟都OK的节点
3、该模块节点与上一次成功节点比较，不一样就拷贝，否则不拷贝
'''


def getlist(obj):
    return obj if isinstance(obj, list) else [obj]

def getstatusoutput(cmd):
    pipe = os.popen(cmd + ' 2>&1', 'r')
    text = pipe.read()
    sts = pipe.close()
    if sts is None: sts = 0
    if text[-1:] == '\n': text = text[:-1]
    return sts, text

def savePid2File(fileName):
    pid = os.getpid()
    f = open(fileName, "w")
    f.write(str(pid))
    f.close()	
	
def systemCall(cmdLine):
    log = ""
    log = log + cmdLine + "\n"
    ret, text = getstatusoutput(cmdLine)
    log = log + text
    return ret, log

def getCurTimeStr():
    return time.strftime('%Y-%m-%d %X',time.localtime(time.time()))

def fileListSortByCreateTime(pkgRoot, prefix):
    '''
    按时间给符合条件的目录排序（需过滤）
    '''
    fileList = glob.glob(os.path.join(pkgRoot, prefix + '*'))
    fileList.sort(key = lambda x: os.path.getctime(x))
    fileList.reverse()
    return fileList

def isSuccVer(dirName, smokeList):
    for board in smokeList:
        log = board
        print(log)
        flgFile = os.path.join(dirName, board + '_ok.txt')
        if not os.path.isfile(flgFile):
            return False
    return True

def findLastSuccByMod(pkgList, smokeList):
    '''
    按模块寻找最新冒烟OK的软件包
    '''
    for pkgDir in pkgList:
        if isSuccVer(pkgDir, smokeList):
            return pkgDir

    return None

def copyDir(srcDir, desDir):
    log = ""
    log = log +  "copy %s -> %s"%(srcDir, desDir)
    ret, text = systemCall(r"robocopy %s %s /E /Z /FFT /W:10 /R:5 /COPY:DT /MT:120 /ZB /NS /NC /NFL /NDL /NP /XX" %(srcDir, desDir))
    log = log + text
    if ret >=8 or ret == -1:
	    print(log)
	    raise AssertionError, "robocopy error!!!"

    #shutil.copytree(srcDir, desDir)
    return log

def clearDir(dire):
    if os.path.isdir(dire):
        #shutil.rmtree(dire)
        getstatusoutput("rmdir /s/q \"%s\"" %(dire))

def copyPkg(srcPkg, desModDir, pkg_prefix, pkg_pstfix):
    # 清空模块软件包
    log = ""
    clearDir(desModDir)

    # 拷贝基础包
    srcCommDir = os.path.join(srcPkg, pkg_prefix)
    desCommDir = os.path.join(desModDir, pkg_pstfix)
    log = log + "%s\r\n"%srcCommDir
    log = log + "%s\r\n"%desCommDir

    log = log + "%s\r\n"%copyDir(srcCommDir, desCommDir)
    pkg_prefix = pkg_prefix.split('\\')[0]

    # 拷贝冷补丁
    for srcSpcDir in glob.glob(os.path.join(srcPkg, 'SPC', pkg_prefix + '*')):
        desSpcDir = os.path.join(desModDir, 'SPC', os.path.basename(srcSpcDir))
        log = log + "%s\r\n"%copyDir(srcSpcDir, desSpcDir)

    if pkg_prefix == "TDS": patType = "*_T"
    else:   patType = pkg_prefix + '_*'
    # 拷贝热补丁
    for srcSphDir in glob.glob(os.path.join(srcPkg, 'Hotpatch', patType)):
        desSphDir = os.path.join(desModDir, 'HotPath', os.path.basename(srcSphDir))
        log = log + "%s\r\n"%copyDir(srcSphDir, desSphDir)

    return log

def mkDir(fileName):
    fileName = os.path.abspath(fileName)
    dirList = fileName.split(os.sep)

    dirName = dirList[0]
    if dirName == "":
        beginIdx = 3
    else:
        beginIdx = 1
    for i in range(1, len(dirList)):
        dirName += os.sep + dirList[i]
        if i <= beginIdx: continue
        if not os.path.isdir(dirName):
            os.mkdir(dirName)

def writeSucc(succfile, ver):
    fp = open(succfile, 'w')
    fp.write(ver)
    fp.close()

def readLine(file):
    fp = open(file)
    text = fp.read()
    text = text.split()[0]
    text = text.strip()
    fp.close()
    return text

def readLastSucc(succFile):
    if os.path.isfile(succFile):
        return readLine(succFile)
    return None

def copyRes(srcPkg, desModDir, pkgList):
    log = ""
    resDir = os.path.join(srcPkg, "artifacts", "res")
    if os.path.isdir(resDir):
        log = log + "xcopy %s\\*macro_en.ini %s\\res\\ /y/r/i/s" %(resDir, desModDir)
        getstatusoutput("xcopy %s\\*macro_en.ini %s\\res\\ /y/r/i/s" %(resDir, desModDir))
    return log

def ExitSet(mod, log):
    global threadExitNum
    global mutex
    mutex.acquire()
    print("\n=================")
    print(log)
    print("[%s][模块: %s]第%s名完成......"%(getCurTimeStr(), mod, threadExitNum+1))
    print("=================\n")
    threadExitNum = threadExitNum + 1
    mutex.release()
    return True

def singleModCpSoftware(pkgList, mod):
    log = ""
    try:
        succPkg = findLastSuccByMod(pkgList, env_info[mod]['smokeLst'])
        if not succPkg:
            log = log + "模块%s无可用包\r\n" %mod
            return ExitSet(mod, log)

        succFile = os.path.join(os.environ["SUCC_ROOT_PATH"], mod, "succ.txt")
        succVersion = os.path.basename(succPkg)
        if succVersion == readLastSucc(succFile):
            log = log + "\n模块%s的版本未更新\r\n" %mod
            return ExitSet(mod, log)

        print("start %s copy......"%mod)
        log = log + "更新模块%s:\n" %mod
        desModDir = os.path.join(DST_PKG_DIR, mod)   # 自动化测试各模块的根目录，如HERT306C00_Daily_Soft\LTE
        log = log + "%s\r\n"%copyPkg(succPkg, desModDir, env_info[mod]['pkg_prefix'], env_info[mod]['pkg_pstfix'])
        log = log + "%s\r\n"%copyRes(succPkg, desModDir, pkgList)
        log = log + "\nwrite succfile ...\r\n"
        mkDir(os.path.dirname(succFile))
        writeSucc(succFile, succVersion)
        writeSucc(os.path.join(desModDir, "succ.txt"), succVersion)
    except:
        print("%s :拷贝出现异常"%mod)
        print sys.exc_info()[0],sys.exc_info()[1]
        returnValuelst.append([mod, False])

    return ExitSet(mod, log)

def updateAutociPkg(pkgRoot, prefix, env_info, desPkgDir):
    #auto clear src dir
    pkgList = fileListSortByCreateTime(pkgRoot, prefix)
    print pkgList
    while(len(pkgList) > 250):
        print "rmdir /s /q %s" %(pkgList[-1])
        ret = os.system("rmdir /s /q %s" %(pkgList[-1]))
        if ret !=0: print("rm old dir fail")
        pkgList = fileListSortByCreateTime(pkgRoot, prefix)

    print("[%s]start all threads"%getCurTimeStr())
    threadObjList=[]
    for mod in env_info.keys():
		#print("TEST")
        t = threading.Thread(target=singleModCpSoftware, args=(pkgList, mod, ))
        threadObjList.append(t)
        t.start()
        #thread.start_new_thread(singleModCpSoftware, (pkgList, mod))

    #检查当前多少线程已经退出
    while (len(threadObjList)):
        for threadObj in threadObjList:
            if not threadObj.isAlive():
                threadObjList.remove(threadObj)
    
    #while True:
    #    if threadExitNum >= len(env_info.keys()):
    #        break
    return True

if __name__ == "__main__":
    savePid2File("buildpid.txt")
    updateAutociPkg(SRC_PKG_DIR, PREFIX, env_info, DST_PKG_DIR)
    print
    print '*' * 50
    print "\nupdate finished!\n"
    print '*' * 50
    for ret in returnValuelst:
        if ret[1] == False:
            print("模块[%s]向自动化copy软件包失败，请关注"%ret[0])
            exit(1)	
    ret, text = systemCall(r"xcopy %s %s /y/r/i/e/s" %(os.environ["SUCC_ROOT_PATH"], os.path.join(SRC_PKG_DIR_TRIGGER, "trigger", "AutoSuccFiles")))
    print(r"xcopy %s %s /y/r/i/e/s" %(os.environ["SUCC_ROOT_PATH"], os.path.join(SRC_PKG_DIR_TRIGGER, "trigger", "AutoSuccFiles")))
    exit(0)
